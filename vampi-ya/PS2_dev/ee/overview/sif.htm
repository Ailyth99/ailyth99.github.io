<html lang="ja">
<!-- 見出し　１，部見出し -->
<head>

<script language="JavaScript">
<!--
  function startFixed(){
    fixedLAYER('fixedLay0','rightBottom',-35,-35)
  }

  var ie= !!document.all
  var n4= !!document.layers
  var w3c=!!document.getElementById
  var mac45 
    = navigator.userAgent.indexOf('MSIE 4.5; Mac_PowerPC')

  if(document.layers)window.onresize=resizeFunc
  function resizeFunc(e){location.reload()}

  function iniFunc(){
    if(ie&&!(mac45!=-1))window.onscroll = startFixed
    startFixed()
  }

  var tid=new Array()

  function fixedLAYER(layName,posString,offSetX,offSetY){

    offSetX = parseInt(offSetX,10)
    offSetY = parseInt(offSetY,10)

 if( posString == 'rightBottom' ){

      if(ie) offLeft = document.body.clientWidth   + offSetX
      else   offLeft = window.innerWidth           + offSetX
      if(ie) offTop  = document.body.clientHeight  + offSetY
      else   offTop  = window.innerHeight          + offSetY

    }
    else {

      if(ie) offLeft =                               offSetX
      else   offLeft =                               offSetX
      if(ie) offTop  =                               offSetY
      else   offTop  =                               offSetY

    }

    offLeft = parseInt(offLeft)
    offTop  = parseInt(offTop)

    if(document.all){
      var mx = parseInt(document.body.scrollLeft +offLeft)
      var my = parseInt(document.body.scrollTop  +offTop)
    } else {
      var mx = parseInt(self.pageXOffset+offLeft)
      var my = parseInt(self.pageYOffset+offTop)

    }

    moveLAYER(layName,mx,my)

    if(!(ie&&!(mac45!=-1)))
      setTimeout("fixedLAYER('"+layName+"','"+posString
                   +"','" +offSetX+"','"+offSetY+"')",100)
  }

  function moveLAYER(layName,x,y){
      
      if(document.getElementById){
        document.getElementById(layName).style.left=x
        document.getElementById(layName).style.top=y
      }
      else if(document.all){
        document.all(layName).style.pixelLeft=x
        document.all(layName).style.pixelTop=y
      }
      else if(document.layers)
        document.layers[layName].moveTo(x,y)
  }

// -->
</script>

<script language="JavaScript">
<!--
  function lj(ch,fm)
  {
    if ( parent.index ) {
      if ( ch == "libref" ){ parent.index.location.href="../libref/category.htm"; }
      else if ( ch == "../ee/libref" ){ parent.index.location.href="../../ee/libref/category.htm"; }
      else if ( ch == "../iop/libref" ){ parent.index.location.href="../../iop/libref/category.htm"; }
      else if ( ch == "../iop/overview" ){ parent.index.location.href="../../iop/overview/category.htm"; }
      else if ( ch == "../ee/overview" ){ parent.index.location.href="../../ee/overview/category.htm"; }
      else if ( ch == "overview" ){ parent.index.location.href="../overview/category.htm"; }
    }
    if ( parent.main ) {
      if ( fm != "" ){ parent.main.location.href=fm; }
    } else {
      if ( fm != "" ){ location.href=fm; }
    }
  }
//-->
</script>

<title>SIFシステム</title>
<meta http-equiv="Content-Type"content= text/html; charset=Shift_JIS >
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta name="Author" Content="Sony Computer Entertainment Inc.">
<style type="text/css"><!--
    div.fixedLay{position:absolute;z-index:100;left:0px;top:0px;}
--></style>
</head>
<body onload="iniFunc()" bgcolor="#ffffff" text="#000000" >
<div id="fixedLay0" class="fixedLay">
<a href="#top"><img src="gif/link.gif" border="0" alt="TOP"></a>
</div>
<table WIDTH="100%">
<tr><td valign=top>
<h3>"PlayStation 2" Programmer Tool Runtime Library Release 2.5.3</h3>
</td>
<td align= right nowrap>
<script language="JavaScript">
<!--
   var p,q;
   if ( parent.index ) {
   p = parent.index.location;
   q = p.toString();
   result = q.match(/\/category\.htm/gi);
   if(result == "/category.htm"){
          document.writeln("<a href=\"JavaScript:lj('libref','../libref/scmd_rf.htm')\"><img src=\"./gif/arrow.png\" border=0>SIF CMD</a><br><a href=\"JavaScript:lj('libref','../libref/sdma_rf.htm')\"><img src=\"./gif/arrow.png\" border=0>SIF DMA</a><br><a href=\"JavaScript:lj('libref','../libref/srpc_rf.htm')\"><img src=\"./gif/arrow.png\" border=0>SIF RPC</a><br><a href=\"JavaScript:lj('libref','../libref/emrpc_rf.htm')\"><img src=\"./gif/arrow.png\" border=0>マルチスレッドSIF RPC(EE)</a><br><a href=\"JavaScript:lj('../iop/libref','../../iop/libref/imrpc_rf.htm')\"><img src=\"./gif/arrow.png\" border=0>マルチスレッドSIF RPC(IOP)</a>");
}
}
// -->
</script>
</td></tr>
</table>
<hr noshade size=6>
<a name=Heading2>
<center><h1>
SIFシステム
</h1></center>
</a>
<div align=center>
<table border=0 bgcolor=#F5F5F5 width=90%><tr><td>
<h2><u>
        <b>目次</b><br>
</u></h2>

<ul>
<p><a href="#Heading3_1">  1 <b>SIFシステムの構成</b></a>
<p><a href="#Heading3_2">  2 <b>SIF DMA API</b></a>
    <ul>
    <a href="#Heading4_2_1"> <b>概要</b><br></a>
    <a href="#Heading4_2_2"> <b>関連ファイル</b><br></a>
    </ul>
<p><a href="#Heading3_3">  3 <b>SIF Command API</b></a>
    <ul>
    <a href="#Heading4_3_1"> <b>概要</b><br></a>
    <a href="#Heading4_3_2"> <b>関連ファイル</b><br></a>
    <a href="#Heading4_3_3"> <b>利用手順</b><br></a>
    <a href="#Heading4_3_4"> <b>サンプルプログラム</b><br></a>
    </ul>
<p><a href="#Heading3_4">  4 <b>SIF RPC API</b></a>
    <ul>
    <a href="#Heading4_4_1"> <b>概要</b><br></a>
    <a href="#Heading4_4_2"> <b>関連ファイル</b><br></a>
    <a href="#Heading4_4_3"> <b>利用手順</b><br></a>
    <a href="#Heading4_4_4"> <b>標準サービス関数</b><br></a>
    <a href="#Heading4_4_5"> <b>サンプルプログラム</b><br></a>
    </ul>
<p><a href="#Heading3_5">  5 <b>マルチスレッド対応SIF RPC</b></a>
    <ul>
    <a href="#Heading4_5_1"> <b>RPC と MRPC の構造上の違い</b><br></a>
    <a href="#Heading4_5_2"> <b>関連ファイル</b><br></a>
    <a href="#Heading4_5_3"> <b>サンプルプログラム</b><br></a>
    <a href="#Heading4_5_4"> <b>プログラミングの注意点</b><br></a>
    </ul>
<p><a href="#Heading3_6">  6 <b>RPC再入に関する注意</b></a>
    <ul>
    <a href="#Heading4_6_1"> <b>RPC再入のしくみ</b><br></a>
    <a href="#Heading4_6_2"> <b>RPC再入の防止</b><br></a>
    <a href="#Heading4_6_3"> <b>RPCを使用するライブラリ関数</b><br></a>
    </ul>
<p><a href="#Heading3_7">  7 <b>IOPモジュールの置き換え</b></a>
    <ul>
    <a href="#Heading4_7_1"> <b>デフォルトモジュールの置き換え</b><br></a>
    <a href="#Heading4_7_2"> <b>デフォルトモジュール以外のモジュールの置き換え</b><br></a>
    <a href="#Heading4_7_3"> <b>IOPモジュールのスレッドプライオリティ指定</b><br></a>
    </ul>
<br></td></tr></table></div>

<!-- 見出し　２，章見出し -->
<a name=#"Heading2">

<!-- 見出し　３，節見出し -->
<a name="Heading3_1">
<h2>
 1 <b>SIFシステムの構成</b>
<hr noshade>
</h2>

<div style="margin-left:50px;">SIF(SubBus I/F)を介してEE - IOP間の通信を行うSIFシステムは、次のような階層構造で構成されています。<br></div>
<div style="margin-left:50px;"></div>
<div style="margin-left:67px;">
<p>
<img src="gif/sif001.gif"><p>

</div>
<br>
<div style="margin-left:50px;">SIF DMA / SIF CMD / SIF RPC(Remote Procedure Call)という3つのレベルで、EE側 / IOP側双方にそれぞれほぼ同一のAPIが用意されています。<br></div>

<!-- 見出し　３，節見出し -->
<a name="Heading3_2">
<h2>
 2 <b>SIF DMA API</b>
<hr noshade>
</h2>


<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_2_1">
<a href="#Heading3_2"> 2. </a>1 <b>概要</b><br>
</a>
</h3>
<div style="margin-left:50px;">SIF DMA APIはSIFシステムのもっとも下位の階層となるAPIです。EEからIOPへ、逆にIOPからEEへ、それぞれ相手側メモリへのDMA転送を行う関数と、転送処理の状態を調べる関数、DMAチャネルの再設定を行う関数が用意されています。<br></div>
<div style="margin-left:50px;"></div>
<div style="margin-left:67px;">
<p>
<img src="gif/sif002.gif"><p>

</div>
<br>
<div style="margin-left:50px;">EE側IOP側ともにSIF DMAの受け口は基本的に常時開いていますので、相手側メモリへのDMA転送は非同期に（相手側の状態を意識せずに）実行することができます。ただし、EEが受け手となる転送の際に、DMA終了割り込みが発生すると、EE側の受け口が閉じます。またIOPが受け手となる転送の際に、SIF_DMA_ERTを指定してDMA終了割り込みを発生させると、IOP側の受け口が閉じます。いずれの場合も、受け手側でDMAチャネルの再設定を行って受け口を開きなおす必要があります。<br></div>

<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_2_2">
<a href="#Heading3_2"> 2. </a>2 <b>関連ファイル</b><br>
</a>
</h3>
<div style="margin-left:50px;">SIF DMA APIを利用するのに必要なファイルは次のとおりです。<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;<b>カテゴリ</b>&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;<b>ファイル名</b>&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;ヘッダファイル&nbsp;</td>
<td valign="TOP">&nbsp;sif.h&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;EE ライブラリ&nbsp;</td>
<td valign="TOP">&nbsp;libkernl.a&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;IOP モジュール&nbsp;</td>
<td valign="TOP">&nbsp;iop.ilb&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- 見出し　３，節見出し -->
<a name="Heading3_3">
<h2>
 3 <b>SIF Command API</b>
<hr noshade>
</h2>


<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_3_1">
<a href="#Heading3_3"> 3. </a>1 <b>概要</b><br>
</a>
</h3>
<div style="margin-left:50px;">SIF CMD(Command) APIはSIF DMA APIの上位階層に位置し、EE / IOPそれぞれ相手側でローカルに定義し登録した関数（コマンド関数）を、コマンドパケットを送ることによって実行させる仕組みです。たとえば、IOP側でIOPアプリケーションの変数を変更するコマンド関数を登録しておけば、EE側からIOPアプリケーションの動作を制御することができます。また逆に、EE側にコマンド関数を登録しておいて、IOPアプリケーションからの指示に応じてアクションを起すこともできます。EE側 / IOP側ともに、ほぼ同一のAPIが実装されています。<br></div>
<div style="margin-left:50px;"></div>
<div style="margin-left:67px;">
<p>
<img src="gif/sif003.gif"><p>

</div>
<br>
<div style="margin-left:50px;">SIF CMD APIは、SIF DMA APIと並行して使用することができます。<br></div>

<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_3_2">
<a href="#Heading3_3"> 3. </a>2 <b>関連ファイル</b><br>
</a>
</h3>
<div style="margin-left:50px;">SIF CMD APIを利用するのに必要なファイルは次のとおりです。<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;<b>カテゴリ</b>&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;<b>ファイル名</b>&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;ヘッダファイル&nbsp;</td>
<td valign="TOP">&nbsp;sifcmd.h&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;EEライブラリ&nbsp;</td>
<td valign="TOP">&nbsp;Libkernl.a&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;IOPモジュール&nbsp;</td>
<td valign="TOP">&nbsp;iop.ilb&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_3_3">
<a href="#Heading3_3"> 3. </a>3 <b>利用手順</b><br>
</a>
</h3>
<div style="margin-left:50px;">まず、初期設定としてEE / IOP双方でsceSifInitCmd()を呼び出します。このときの内部動作は次のとおりです。<br></div>
    <div style="margin-left:55px;"><ol>
         <li VALUE=1> 受信バッファ（8qword）を確保し、そのアドレスを交換する。</li>
         <li VALUE=2> SIF CMD用の割り込みハンドラを登録する。</li>
         <li VALUE=3> ソフトウエアレジスタを初期化する。</li>
</ol></div>
</ul></div>
<div style="margin-left:50px;">次に、受け手となるプロセッサの側でsceSifSetCmdBuffer()を呼び出し、コマンド関数登録用のバッファ（テーブル）を登録します。さらに、sceSifAddCmdHandler()を呼び出し、コマンド関数を登録します。コマンド関数は、割り込み関数として実行されます。コマンド関数を複数登録する場合は、必要なだけsceSifAddCmdHandler()を繰り返します。<br>あとは必要に応じて、適切なコマンドパケットを用意しsceSifSendCmd()を呼び出すことによって、受け手プロセッサに送り実行させます。このときの内部動作は次のとおりです。<br></div>
    <div style="margin-left:55px;"><ol>
         <li VALUE=1> コマンドパケットを相手側の受信バッファへ転送し、転送終了割り込みを発生させる。</li>
         <li VALUE=2> 受け手側でSIF CMD用の割り込みハンドラが動き、受信バッファを検索する。</li>
         <li VALUE=3> 受信バッファにコマンドパケットがあれば、パケットを解析し、適切なコマンド関数を割り込み領域で実行する。<br>受信バッファにデータが何もなければ、そのままリターンする。</li>
</ol></div>
</ul></div>

<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_3_4">
<a href="#Heading3_3"> 3. </a>4 <b>サンプルプログラム</b><br>
</a>
</h3>
<div style="margin-left:50px;">SIF CMD APIを使用するプログラム例として、/sce/ee/sample/sif/sifcmdおよび/sce/iop/sample/sif/sifcmdがあります。<br></div>

<!-- 見出し　３，節見出し -->
<a name="Heading3_4">
<h2>
 4 <b>SIF RPC API</b>
<hr noshade>
</h2>


<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_4_1">
<a href="#Heading3_4"> 4. </a>1 <b>概要</b><br>
</a>
</h3>
<div style="margin-left:50px;">SIF RPC(Remote Procedure Call) APIは、SIF CMD API上に作られた、単純なクライアントサーバモデルを構築する仕組みです。たとえば、IOP側で登録した関数をEEアプリケーションから呼び出し、結果をEEアプリケーションに返させるといったことができます。<br></div>
<div style="margin-left:50px;"></div>
<div style="margin-left:67px;">
<p>
<img src="gif/sif004.gif"><p>

</div>
<br>
<div style="margin-left:50px;">EE / IOP双方にほぼ同一のAPIが用意されているので、上図とは逆にEE側がサーバとなりIOP側がクライアントとなることも可能ですし、両方の役割を同時にこなすことも可能です。<br>また、SIF RPC APIは、SIF DMA API / SIF CMD APIと並行して使用可能です。<br></div>

<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_4_2">
<a href="#Heading3_4"> 4. </a>2 <b>関連ファイル</b><br>
</a>
</h3>
<div style="margin-left:50px;">SIF RPC APIを利用するのに必要なファイルは次のとおりです。<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;<b>カテゴリ</b>&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;<b>ファイル名</b>&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;ヘッダファイル&nbsp;</td>
<td valign="TOP">&nbsp;sifrpc.h&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;EE ライブラリ&nbsp;</td>
<td valign="TOP">&nbsp;libkernl.a&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;IOP モジュール&nbsp;</td>
<td valign="TOP">&nbsp;iop.ilb&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_4_3">
<a href="#Heading3_4"> 4. </a>3 <b>利用手順</b><br>
</a>
</h3>
<div style="margin-left:50px;">SIF RPC APIを使用する際の手順をまとめると次のようになります。<br></div>
<div style="margin-left:50px;"></div>
<div style="margin-left:67px;">
<p>
<img src="gif/sif005.gif"><p>

</div>
<br>
<div style="margin-left:50px;">サーバ側のサービスループ内では、クライアント側からのリクエストがない場合、そのサービスループを呼び出したスレッドはリクエストが来るまではスリープ状態になっています。<br>クライアント側の関数sceSifBindRpc()およびsceSifCallRpc()では、この関数を呼び出したスレッドはサーバ側から応答があるまで、セマフォもしくはイベントフラグによる待ちの状態になっています（同期呼び出し、またはWAIT実行といいます）。また、待ちの状態にならないように呼び出して、sceSifCheckStatRpc()で処理終了を確認することも可能です（非同期呼び出し、またはNOWAIT実行といいます）。<br>なお、同期呼び出しの場合、サービス関数の処理終了はサーバ側からのDMA割り込みで通知されます。したがって、割り込み禁止状態または割り込みハンドラ内で同期呼び出しを行うとハングアップしますので注意してください。<br></div>

<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_4_4">
<a href="#Heading3_4"> 4. </a>4 <b>標準サービス関数</b><br>
</a>
</h3>
<div style="margin-left:50px;">EE側をクライアントとするサービス関数として、入出力サービスと標準IOPサービスの2つが提供されています。詳細はそれぞれ別ドキュメント（libio / libiserv）にまとめてありますので参照してください。<br></div>

<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_4_5">
<a href="#Heading3_4"> 4. </a>5 <b>サンプルプログラム</b><br>
</a>
</h3>
<div style="margin-left:50px;">SIF RPC APIを使用するプログラム例として、/sce/ee/sample/sif/sifrpcおよび/sce/ee/sample/sif/sifrpcがあります。<br></div>

<!-- 見出し　３，節見出し -->
<a name="Heading3_5">
<h2>
 5 <b>マルチスレッド対応SIF RPC</b>
<hr noshade>
</h2>

<div style="margin-left:50px;">libmrpcは、SIFRPC（RPC）の概念にマルチスレッド対応を取り入れたMSIFRPC（MRPC）です。マルチスレッド対応なので、EE側の複数のスレッドから任意のタイミングで関数を呼び出すことができます。ただし、MSIFRPCの制限により、対応できるスレッド数は最大32個となっています。<br></div>

<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_5_1">
<a href="#Heading3_5"> 5. </a>1 <b>RPC と MRPC の構造上の違い</b><br>
</a>
</h3>
<div style="margin-left:50px;">RPC は、サーバ上にてRegistされた関数に対してのサービスは、登録したスレッドで行なわれます。そのため、１つの Registに対して Bind できるクライアントは1つだけとなります。スレッドの生成や消去が行なわれないので Unbind もしません。<br>これに対して MRPC は、Regist したスレッド自身はサービスを行ないません。Bind リクエストがサーバ側に来た時点で、サーバはスレッド１つ作成し、そのスレッドが Regist された関数を実行します。そのため、1つのサーバで複数のサービスを同時に行なえます。<br>生成されたスレッドのプライオリティとスタックサイズおよび受信データのバッファサイズは、デフォルトではそれぞれ32、0x2000 , 0x800となっています。sceSifMBindRpcParam() を使用すれば、それぞれの値を指定することができます。サービスを行なうスレッドは、Unbind リクエストによって消去されます。<br></div>

<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_5_2">
<a href="#Heading3_5"> 5. </a>2 <b>関連ファイル</b><br>
</a>
</h3>
<div style="margin-left:50px;">libmrpcを使用する際に必要なファイルは次のとおりです。<br><br></div>
<div style="margin-left:90px;">
<table border=1>
<tr>
<td valign="TOP" bgcolor="#cccccc">&nbsp;<b>カテゴリ</b>&nbsp;</td>
<td valign="TOP" bgcolor="#cccccc">&nbsp;<b>ファイル名</b>&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;ライブラリファイル&nbsp;</td>
<td valign="TOP">&nbsp;libmrpc.a&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;ヘッダファイル&nbsp;</td>
<td valign="TOP">&nbsp;libmrpc.h&nbsp;</td>
</tr>
<tr>
<td valign="TOP">&nbsp;IOPモジュール&nbsp;</td>
<td valign="TOP">&nbsp;msifrpc.irx&nbsp;</td>
</tr>
</table>
</div>
<br>

<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_5_3">
<a href="#Heading3_5"> 5. </a>3 <b>サンプルプログラム</b><br>
</a>
</h3>
<div style="margin-left:50px;">libmrpcを使用するサンプルプログラムは、ソース公開のLibnetライブラリ（ネットワークライブラリ）を参照ください。<br>また、libmrpcの関数リファレンスに各関数の使用上の注意点が書かれています。<br><br></div>

<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_5_4">
<a href="#Heading3_5"> 5. </a>4 <b>プログラミングの注意点</b><br>
</a>
</h3>

<div style="margin-left:40px;"><h4><b>転送の単位</b><br></h4></div>

<div style="margin-left:67px;">MSIFRPCで使用されるバッファの単位や、転送されるデータサイズの単位に注意してください。<br>バッファの単位は、EE側が16 bytes align、IOP側が4 bytes alignですが、これはキャッシュを見切った場合です。キャッシュを考慮すると64 bytes alignとなるので、通常アプリケーションでは64 bytes alignで組むことをお勧めします。つまり、MSIFRPCで使われるバッファは、先頭アドレスが64 bytes alignで、かつ領域サイズも64バイト単位で確保することを意味します。併せて、転送するデータサイズの単位も64バイト単位にすることで混乱を防ぐことになります。<br></div>

<div style="margin-left:40px;"><h4><b>転送バッファの共有</b><br></h4></div>

<div style="margin-left:50px;">ある1つのスレッドが1つのバッファを送信用と受信用として共有することは可能ですが、複数のスレッドが1つの送信バッファを共有することはできません。同様に、複数のスレッドが1つの受信バッファを共有することもできません、つまり、複数のスレッドで使用する場合は、スレッドごとにバッファを分けてください。もちろん、スレッドごとに確保された1つのバッファを送信用と受信用で共有することは可能です。<br></div>

<!-- 見出し　３，節見出し -->
<a name="Heading3_6">
<h2>
 6 <b>RPC再入に関する注意</b>
<hr noshade>
</h2>


<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_6_1">
<a href="#Heading3_6"> 6. </a>1 <b>RPC再入のしくみ</b><br>
</a>
</h3>
<div style="margin-left:50px;">SIF RPC APIで呼び出すサービス関数は再入不可能です。関数自体が再入可能（リエントラント）にコーディングされていても、RPC経由での再入はできません。<br>クライアント側から見ると、あるサービス関数をsceSifCallRpc()で呼び出したらその処理が終了しないうちに重ねて呼び出すことはできない、ということになります。もし重ねて呼び出すと、多くの場合、適切なデータが得られずクライアント側でライブラリの内部関数 _sceRpcFreePacket()がハングアップするという症状が現れます。<br>このような再入が引き起こされるのは、複数のスレッドで同じサービス関数を利用している場合、さらに詳しく言うと次の2つのケースです。<br></div>

<div style="margin-left:40px;"><h4><b>WAIT実行で再入が起こるケース</b><br></h4></div>

    <div style="margin-left:55px;"><ol>
         <li VALUE=1> あるスレッド(A)でsceSifCallRpc(&bd)をWAIT実行する</li>
         <li VALUE=2> sceSifCallRpc(&bd)内部でセマフォ待ちに入り、別のスレッド(B)に実行権が移る</li>
         <li VALUE=3> スレッド(B)でsceSifCallRpc(&bd)を実行する……(1)のsceSifCallRpc(&bd)が終了していなければ再入が起こる</li>
</ol></div>
</ul></div>

<div style="margin-left:40px;"><h4><b>NOWAIT実行で再入が起こるケース</b><br></h4></div>

    <div style="margin-left:55px;"><ol>
         <li VALUE=1> あるスレッド(A)でsceSifCallRpc(&bd)をNOWAIT実行する</li>
         <li VALUE=2> 何らかの割り込みが起こり、割り込みハンドラに制御が移る</li>
         <li VALUE=3> 割り込みハンドラ内部で、スレッド(A)より優先度の高いスレッド(B)が起床される</li>
         <li VALUE=4> 割り込みハンドラから復帰し、スレッド(B)に実行権が移る</li>
         <li VALUE=5> スレッド(B)でsceSifCallRpc(&bd)を実行する……(1)のsceSifCallRpc(&bd)が終了していなければ再入が起こる</li>
</ol></div>
</ul></div>

<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_6_2">
<a href="#Heading3_6"> 6. </a>2 <b>RPC再入の防止</b><br>
</a>
</h3>
<div style="margin-left:50px;">RPC再入が起こらないようにするには、次のような方法があります。<br></div>
<div style="margin-left:40px;"><ul>
         <li> 同じClientDataを使用するsceSifCallRpc()はひとつのスレッドでまとめて実行する
         <li> 同じClientDataを使用するsceSifCallRpc()を複数のスレッドで実行する場合は、セマフォ等を用いて排他制御する（スレッドセーフな構造）
</ul></div>

<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_6_3">
<a href="#Heading3_6"> 6. </a>3 <b>RPCを使用するライブラリ関数</b><br>
</a>
</h3>
<div style="margin-left:50px;">SCEが提供しているライブラリ関数のうち以下に挙げるものは、内部でsceSifCallRpc()を使用しています。基本的に、同じライブラリに属する関数は同じClientDataを使用していますので、上記のような方法で、RPC再入が起こらないように注意して利用してください。<br></div>
<div style="margin-left:40px;"><ul>
         <li> libpadの一部の関数
         <li> libmtapの各関数
         <li> libmcのほとんどの関数
         <li> libmcxのほどんどの関数
         <li> libcdvdのほとんどの関数
         <li> libsdrの一部の関数
         <li> 標準IOPサービスのほとんどの関数
         <li> 入出力サービスのほとんどの関数
</ul></div>
<div style="margin-left:50px;">詳細は各ライブラリのオーバービューを参照してください。<br></div>

<!-- 見出し　３，節見出し -->
<a name="Heading3_7">
<h2>
 7 <b>IOPモジュールの置き換え</b>
<hr noshade>
</h2>


<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_7_1">
<a href="#Heading3_7"> 7. </a>1 <b>デフォルトモジュールの置き換え</b><br>
</a>
</h3>
<div style="margin-left:50px;">IOP側にはデフォルトでいくつかのモジュールがROMからロードされていますが、これを置き換えるためには、いったんIOPシステムをリブートしてOSを再起動する必要があります。その際に、リプレースモジュール（置き換える新しいモジュール）をイメージファイルとして指定します。イメージファイルはライブラリのバージョンに合わせて提供されます。<br>アプリケーションでは、ディスクから起動後すぐにIOPをリブートしてデフォルトモジュールを置き換えるようにしてください。<br>DTL-T10000 の dsidb (IOP 側コンソール) にて、入れ替え時に表示されるメッセージを確認してください。<br></div>
    <div style="margin-left:55px;"><ol>
         <li VALUE=1> 正常実行時<br>dsidb&gt;<br>Update reboot complete </li>
         <li VALUE=2> 失敗時の例（ファイル名を誤っている）<br>dsidb&gt;<br>Update rebooting..<br>open file name ********.***;1<br>file 'cdrom0:********.***;1' can't open<br>***Resetted</li>
</ol></div>
</ul></div>
<div style="margin-left:50px;"><br>プログラム例を以下に示します。<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>#include  &lt;eekernel.h&gt;
#include  &lt;eeregs.h&gt;
#include  &lt;sifdev.h&gt;
#include  &lt;stdio.h&gt;
#include  &lt;libcdvd.h&gt;

#define CDROM      /* CDROM 使用 */
#define REPLACE    /* モジュール入れ替えをする */

#ifdef CDROM
#define IOPRP "cdrom0:\\MODULES\\"IOP_IMAGE_FILE";1"
#else
#define IOPRP "host0:/usr/local/sce/iop/modules/"IOP_IMAGE_file
#endif

int main()
{
#ifdef REPLACE
#ifdef CDROM
  sceSifInitRpc(0);
  sceCdInit(SCECdINIT);
#else
  sceSifInitRpc(0);
#endif /* CDROM */
  while (!sceSifRebootIop (IOPRP)); /* IOPリブート・モジュール置き換え */
  while( !sceSifSyncIop() );        /* 終了を待つ */
#endif /* REPLACE */

  sceSifInitRpc(0);
  sceSifLoadFileReset();
  sceFsReset();
#ifdef CDROM
  sceCdInit(SCECdINIT);
  sceCdMmode(SCECdCD);      /* Media: CD-ROM */
#endif

/* デフォルト以外のモジュールの起動 */
  while (sceSifLoadModule(...) &lt; 0);
  while (sceSifLoadModule(...) &lt; 0);
        :
        :
}

</pre></font></div>
<div style="margin-left:50px;">プログラム内で使用されているマクロIOP_IMAGE_FILE、IOP_IMAGE_fileは、<br>Release1.6よりIOPリプレースモジュールをsifdev.hで以下のように定義しました。このファイル名はリリースごとに更新されます。<br><br></div>
<div style="margin-left:67px;">&lt;sifdev.h&gt;<br></div>
        <div style="margin-left:80px;"><pre><font size=3>#define IOP_IMAGE_FILE "IOPRPXX.IMG"
#define IOP_IMAGE_file "ioprpXX.img"
</pre></font></div>
<div style="margin-left:50px;"><br>これにより、IOP デフォルトモジュールの置き換えの際に以下のような指定方法が可能となり、ライブラリのアップデートのみ行う場合の修正作業が不要となります。<br><br></div>
<div style="margin-left:67px;">記述例）<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>#ifdef CDROM
  // CD/DVD-ROM ディスクから起動する場合(CD/DVD-ROM 内のIOPreplace モジュール参照)
  while (!sceSifRebootIop ("cdrom0:\\" IOP_IMAGE_FILE ";1"));
#else
  // ローカルディスク内の IOP リプレースモジュールを参照する場合
  while (!sceSifRebootIop ("host0:/usr/local/sce/iop/modules/"
  IOP_IMAGE_file));
#endif
</pre></font></div>
<div style="margin-left:50px;"><br>sceSifRebootIop()を発行してsceSifSyncIop()が0以外を返すまでの間、printf()を含めて、IOPを介するサービスは一切使用できません（EEのコプロセッサの制御は可能です）。<br>また、SIFCMD / SIFRPCおよびDECIの設定もすべてリセットされますので、再設定を行ってください。sceOpen() / sceRead()についてはsceFsReset()、libcdvdについては、sceCdInit()を呼び出します。<br></div>

<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_7_2">
<a href="#Heading3_7"> 7. </a>2 <b>デフォルトモジュール以外のモジュールの置き換え</b><br>
</a>
</h3>
<div style="margin-left:50px;">デフォルトモジュール以外のモジュールを置き換えるには、上記のプログラム例にもありますが、IOPをリブートしてから再びsceSifLoadModule()を実行してください。<br></div>

<!-- 見出し　４，小見出し -->
<h3>
<a name="Heading4_7_3">
<a href="#Heading3_7"> 7. </a>3 <b>IOPモジュールのスレッドプライオリティ指定</b><br>
</a>
</h3>
<div style="margin-left:50px;">sceSifLoadModule()でIOP側モジュールを起動する際に、そのモジュールが実行されるスレッドのプライオリティを指定することができます。次に示すように、第3引数で指定してください。<br>padの場合：<br><br></div>
        <div style="margin-left:80px;"><pre><font size=3>char* mes = "thpri=32,34"; &lt;- 変更したい値を設定する
sceSifLoadModule( "host0:/usr/local/sce/iop/modules/padman.irx", strlen(mes)+1, mes );
</pre></font></div>
<div style="margin-left:50px;"><br>また、IOP側モジュールを持つ各ライブラリ（libpadを除く）には、動作中のモジュールのスレッドプライオリティを変更する関数（sce<i>XXX</i>ChangeThreadPriority()）が用意されています。<br>詳しくは各ライブラリのドキュメントを参照してください。<br></div>
<p><p><hr>
<div ALIGN="right">
    Copyright (c) 2002 Sony Computer Entertainment Inc.  All Rights Reserved.<br>
    SCE CONFIDENTIAL
</div>
</body>
</html>
